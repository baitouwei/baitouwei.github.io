<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>baitouwei</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.baitouwei.com/"/>
  <updated>2016-04-26T02:25:25.000Z</updated>
  <id>http://www.baitouwei.com/</id>
  
  <author>
    <name>baitouwei</name>
    <email>yangcaitao@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Immutable 和 Unmodifiable 的区别</title>
    <link href="http://www.baitouwei.com/2016/04/21/Immutable-%E5%92%8C-Unmodifiable-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://www.baitouwei.com/2016/04/21/Immutable-和-Unmodifiable-的区别/</id>
    <published>2016-04-21T10:06:31.000Z</published>
    <updated>2016-04-26T02:25:25.000Z</updated>
    
    <content type="html">&lt;p&gt;要区分这两个概念，需要先弄明白 Java 是 &lt;a href=&quot;http://www.javaranch.com/campfire/StoryPassBy.jsp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Pass-by-Value(值传递)&lt;/a&gt;的。当 Java 在传递 primitive 变量的时候，是 copy value then pass value；当 Java 在传递引用型变量的时候，是 copy reference of value then pass the reference。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4&gt;Immutable（不可变） Vs Mutable（可变）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Mutable Objects：即持有一个实例对象的引用时，引用指向的对象&lt;strong&gt;可以&lt;/strong&gt;发生改变。&lt;/li&gt;
&lt;li&gt;Immutable Objects：即持有一个实例对象的引用时，引用指向的对象&lt;strong&gt;不可以&lt;/strong&gt;发生改变。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简而言之，Mutable 和 Immutable 的区别就是在对象的值发生改变的时候，对象会不会对新值生成一个新的引用，如果会，则是 Mmutable；否则则是 Immutable。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//Mutable&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Point myPoint = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Point( &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println( myPoint );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myPoint.setLocation( &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt; );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println( myPoint );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//Immutable&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String myString = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String( &lt;span class=&quot;string&quot;&gt;&quot;old String&quot;&lt;/span&gt; );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println( myString );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myString.replaceAll( &lt;span class=&quot;string&quot;&gt;&quot;old&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;new&quot;&lt;/span&gt; );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println( myString );&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;result:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;java.awt.Point[0.0, 0.0]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;java.awt.Point[1.0, 0.0]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;old String&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;old String&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4&gt;Unmodifiable（不可修改） Vs Modifiable（可修改）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Unmodifiable：即变量值&lt;strong&gt;不可以&lt;/strong&gt;被修改&lt;/li&gt;
&lt;li&gt;Modifiable：即变量值&lt;strong&gt;可以&lt;/strong&gt;被修改&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Immutable VS Modifiable&lt;/h4&gt;
&lt;p&gt;Immutable 和 Modifiable 讨论的是不同的内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Immutable：讨论的是变量的引用是否发生更改&lt;/li&gt;
&lt;li&gt;Modifiable：讨论的是变量的值是否发生更改&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Others&lt;/h3&gt;
&lt;h4&gt;Template for Immutable Classes&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Make all fields private&lt;/li&gt;
&lt;li&gt;Don&#39;t provide mutators(不提供 setter)&lt;/li&gt;
&lt;li&gt;Ensure that methods can&#39;t be overridden by either making the class final (Strong Immutability) or making your methods final (Weak Immutability)&lt;/li&gt;
&lt;li&gt;If a field isn&#39;t primitive or immutable, make a deep clone on the way in and the way out.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;参考&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javaranch.com/journal/2003/04/immutable.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;immutable&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.javaranch.com/campfire/StoryPassBy.jsp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;StoryPassBy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/8892350/immutable-vs-unmodifiable-collection&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;immutable-vs-unmodifiable-collection&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;要区分这两个概念，需要先弄明白 Java 是 &lt;a href=&quot;http://www.javaranch.com/campfire/StoryPassBy.jsp&quot;&gt;Pass-by-Value(值传递)&lt;/a&gt;的。当 Java 在传递 primitive 变量的时候，是 copy value then pass value；当 Java 在传递引用型变量的时候，是 copy reference of value then pass the reference。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>App 缓存方案：Http 缓存</title>
    <link href="http://www.baitouwei.com/2016/04/20/App-%E7%BC%93%E5%AD%98%E6%96%B9%E6%A1%88%EF%BC%9AHttp-%E7%BC%93%E5%AD%98/"/>
    <id>http://www.baitouwei.com/2016/04/20/App-缓存方案：Http-缓存/</id>
    <published>2016-04-20T15:27:43.000Z</published>
    <updated>2016-04-26T02:53:36.000Z</updated>
    
    <content type="html">&lt;p&gt;最近考虑在 App 中加入缓存机制，主要是出于两点考虑：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;优化体验。App 启动的时候可以使用缓存数据去填充页面，一进来就出现空白的加载页面。&lt;/li&gt;
&lt;li&gt;为用户在断网情况下继续提供数据浏览。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;综合考虑后，感觉使用 Http 提供的缓存机制比较合适。主要是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;灵活。客户端和服务器都可以对缓存进行控制。&lt;/li&gt;
&lt;li&gt;集成简单。由于 App 使用了 OkHttp，本身就支持 Http 的缓存机制，而且由于是在 Http 层对缓存进行支持，客户端不用添加其他的判断逻辑对是否缓存进行判断。&lt;/li&gt;
&lt;li&gt;跨平台。由于是在 Http 上进行支持的，所以如果需要, iOS 端也可以做相应的支持。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;缺点的话，由于 Http 的缓存是基于文件系统的，也就是 key-value 模式，缓存的粒度比较大，不能实现一些元数据的公用。不过对目前的 App 来说够用了。下面都是对 Http 的缓存机制相关调研。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2&gt;缓存流程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/image/CacheFlow.png&quot; alt=&quot;CacheFlow&quot;&gt;&lt;/p&gt;
&lt;h2&gt;Cache-Control 相关头域&lt;/h2&gt;
&lt;p&gt;Cache-Control 头域分两种，一种用于 Request 的，一种是用于 Response 的，由于 Request 和 Response 都可以有 Cache-Control 头域，所以 Client 和 Server 都可以对缓存机制进行对应的控制。比如当 C 端要强制更新的时候，可以发送带 &lt;code&gt;Cache control: no-store&lt;/code&gt; 的 Request。&lt;/p&gt;
&lt;h4&gt;Request Cache-Control&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&amp;quot;no-cache&amp;quot;&lt;/li&gt;
&lt;li&gt;&amp;quot;no-store&amp;quot;&lt;/li&gt;
&lt;li&gt;&amp;quot;max-age&amp;quot; &amp;quot;=&amp;quot; delta-seconds&lt;/li&gt;
&lt;li&gt;&amp;quot;max-stale&amp;quot; &amp;quot;=&amp;quot; delta-seconds&lt;/li&gt;
&lt;li&gt;&amp;quot;min-fresh&amp;quot; &amp;quot;=&amp;quot; delta-seconds&lt;/li&gt;
&lt;li&gt;&amp;quot;no-transform&amp;quot;&lt;/li&gt;
&lt;li&gt;&amp;quot;only-if-cached&amp;quot;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Response Cache-Control&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&amp;quot;public&amp;quot;&lt;/li&gt;
&lt;li&gt;&amp;quot;private&amp;quot;&lt;/li&gt;
&lt;li&gt;&amp;quot;no-cache&amp;quot;&lt;/li&gt;
&lt;li&gt;&amp;quot;no-store&amp;quot;&lt;/li&gt;
&lt;li&gt;&amp;quot;no-transform&amp;quot;&lt;/li&gt;
&lt;li&gt;&amp;quot;must-revalidate&amp;quot;&lt;/li&gt;
&lt;li&gt;&amp;quot;proxy-revalidate&amp;quot;&lt;/li&gt;
&lt;li&gt;&amp;quot;max-age&amp;quot; &amp;quot;=&amp;quot; delta-seconds&lt;/li&gt;
&lt;li&gt;&amp;quot;s-maxage&amp;quot; &amp;quot;=&amp;quot; delta-seconds&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;不同头域的意义&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Cache-Control:public        ：该 response 为公有缓存&lt;/li&gt;
&lt;li&gt;Cache-Control:private       ：该 response 为私有缓存&lt;/li&gt;
&lt;li&gt;Cache-Control:no-cache      ：可以缓存 response，但是必须要经过新鲜度再验证响应后才可以返回缓存。&lt;/li&gt;
&lt;li&gt;Cache-Control:no-store      ：对应的 resquest/response 不允许存储，这里的不允许存储即：不允许进行任何持久化存储，如果有存在非持久化存储，也要尽快消除。&lt;/li&gt;
&lt;li&gt;Cache-Control:s-maxage      : 意思和 max-age 类似，但是只用于公有缓存，在共有缓存中使用的时候会覆盖 max-age 的值&lt;/li&gt;
&lt;li&gt;Cache-Control:max-age = s   ：指定相对过期日期，单位为秒&lt;/li&gt;
&lt;li&gt;Expires                     ：指定绝对过期日期&lt;/li&gt;
&lt;li&gt;Cache-Control:max-stale = s ：过期后的 s 秒内缓存可以继续使用&lt;/li&gt;
&lt;li&gt;Cache-Control:min-fresh = s ：至少在 s 秒内缓存要保持新鲜&lt;/li&gt;
&lt;li&gt;Cache-Control:must-revalidate      : 强制缓存重新进行新鲜度验证，因为 http 头中存在一些头域会改变缓存原本的失效时间（比如 request 中的 max-stale），而通过这个头域可以强制缓存进行更新，如果在进行新鲜度验证的时候不能连接到服务器，则返回 504 Gateway Timeout 错误。&lt;/li&gt;
&lt;li&gt;Cache-Control:no-transform      : 部分网络代理为了提高性能会对图片等文档进行转换处理(比如压缩)，no-transform 可以强制要求网络代理不要对资源进行转换。&lt;/li&gt;
&lt;li&gt;Cache-Control:only-if-cached      : 该头域表示不进行与网络相关的交互，只返回已经缓存且满足要求的数据，否则的话返回 504 错误。&lt;/li&gt;
&lt;li&gt;Cache-Control:proxy-revalidate      : 和 must-revalidate 类似，只是特定用于公共缓存的。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;PS:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;max-age 的优先级比 Expires 高。
See:&lt;a href=&quot;http://stackoverflow.com/questions/7549177/expires-vs-max-age-which-one-takes-priority-if-both-are-declared-in-a-http-resp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;max-age，max-stale 和 min-fresh 的关系：缓存使用期 age 表示缓存自 Server 将其发出（或最后一次被服务器再验证）之后过去的时间，则如果 age + min-fresh &amp;lt; max-age，缓存未过期；如果 age + min-fresh &amp;gt;= max-age &amp;amp;&amp;amp; age + min-fresh &amp;lt; max-age + max-stale，则虽然缓存过期了，但是缓存继续可以使用，只是在头部添加 110 警告码；如果 age + min-fresh &amp;gt;= max-age + max-stale，则缓存过期且不可使用。缓存使用期 age 的计算可以参考《Http 权威指南》的 7.11.2 节，具体关于缓存使用期和新鲜生存期的问题可以参考 7.11 节。（&lt;a href=&quot;http://stackoverflow.com/questions/33818854/what-is-difference-between-max-age-and-max-stale-in-cache-control-mechanism&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;参考1&lt;/a&gt;,&lt;a href=&quot;https://github.com/square/okhttp/blob/master/okhttp/src/main/java/okhttp3/internal/http/CacheStrategy.java&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;参考2&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;no-cache 和 max-age = 0 的区别：&lt;a href=&quot;http://stackoverflow.com/questions/1046966/whats-the-difference-between-cache-control-max-age-0-and-no-cache&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;no-cache 和 no-store 区别：no-cache 实际会进行缓存，只是在缓存响应之前会先进行一次新鲜度再验证（浏览器的 f5 刷新）；而 no-store 不会进行缓存，每次都是向获取服务器的最新数据（浏览器的强制刷新）。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2&gt;新鲜度再验证的实现&lt;/h2&gt;
&lt;p&gt;有两种实现方式最近修改日期（If-Modified-Since)和实体标签（ETag）验证。
相关首部：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If-Modified-Since:&lt;data&gt;&lt;/data&gt;&lt;/li&gt;
&lt;li&gt;If-Unmodified-Sinece:&lt;data&gt;&lt;/data&gt;&lt;/li&gt;
&lt;li&gt;If-None-Match:&lt;tags&gt;&lt;/tags&gt;&lt;/li&gt;
&lt;li&gt;If-Range:&amp;lt;data|tags&amp;gt;&lt;/li&gt;
&lt;li&gt;If-Match:&lt;tags&gt;&lt;/tags&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;最近修改日期（If-Modified-Since）验证：&lt;/h4&gt;
&lt;p&gt;一般通过 If-Modified-Since 配和 Last-Modified 来实现验证，Last-Modified &amp;gt;= If-Modified-Since 则新鲜度过期。也可配合 If-Unmodified-Sinece。&lt;/p&gt;
&lt;h4&gt;实体标签（ETag）验证：&lt;/h4&gt;
&lt;p&gt;通过特定标签对比进行验证，比如 ETag 可以用来存版本号，这样就可以通过版本号对比查看新鲜度，可以配合 If-None-Match 来使用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;主要使用前两个 If-Modified-Since 和 If-None-Match 头域，详细参考《Http 权威指南》的 7.8.5,7.8.6 节&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;试探性过期&lt;/h4&gt;
&lt;p&gt;当 response 中没有 Cache-Control:max-age 和 Expires 的时候，缓存可以计算出一个试探性最大使用期。常用算法 LM—Factor 算法。&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9.5&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Header Field Definitions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.mobify.com/blog/beginners-guide-to-http-cache-headers/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;A Beginner&#39;s Guide to HTTP Cache Headers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/square/okhttp/blob/master/okhttp/src/main/java/okhttp3/internal/http/CacheStrategy.java&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;OkHttp 源码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;《Http 权威指南》&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近考虑在 App 中加入缓存机制，主要是出于两点考虑：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;优化体验。App 启动的时候可以使用缓存数据去填充页面，一进来就出现空白的加载页面。&lt;/li&gt;
&lt;li&gt;为用户在断网情况下继续提供数据浏览。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;综合考虑后，感觉使用 Http 提供的缓存机制比较合适。主要是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;灵活。客户端和服务器都可以对缓存进行控制。&lt;/li&gt;
&lt;li&gt;集成简单。由于 App 使用了 OkHttp，本身就支持 Http 的缓存机制，而且由于是在 Http 层对缓存进行支持，客户端不用添加其他的判断逻辑对是否缓存进行判断。&lt;/li&gt;
&lt;li&gt;跨平台。由于是在 Http 上进行支持的，所以如果需要, iOS 端也可以做相应的支持。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;缺点的话，由于 Http 的缓存是基于文件系统的，也就是 key-value 模式，缓存的粒度比较大，不能实现一些元数据的公用。不过对目前的 App 来说够用了。下面都是对 Http 的缓存机制相关调研。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Retrofit 分析</title>
    <link href="http://www.baitouwei.com/2016/04/13/Retrofit-%E5%88%86%E6%9E%90/"/>
    <id>http://www.baitouwei.com/2016/04/13/Retrofit-分析/</id>
    <published>2016-04-13T07:32:57.000Z</published>
    <updated>2016-04-13T07:53:44.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;基于 Retrofit 2.0.1 版&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3&gt;源码结构&lt;/h3&gt;
&lt;h4&gt;入口 Retrofit 类：&lt;/h4&gt;
&lt;p&gt;Retrofit 类是这个库的入口，整个库所支持的特性都可以在这里看到。想看看它的 Builder 几个主要方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;create（final Class&lt;t&gt; service）：这里是整个库的入口。传入一个接口，Retrofit 通过动态代理，最终将接口转为一个 Call 并返回给使用者。&lt;/t&gt;&lt;/li&gt;
&lt;li&gt;callbackExecutor（Executor executor）：配置回调用的 Executor，Executor 可以对回调进行调度。&lt;/li&gt;
&lt;li&gt;addConverterFactory(Converter.Factory factory)，addCallAdapterFactory(CallAdapter.Factory factory)：配置对应的 Converter 或 CallAdapter，这个会在核心接口里面说。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;几个核心接口和类：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Call 接口：表示一次 http 请求，包含 request 和 response。可以通过 &lt;code&gt;execute&lt;/code&gt; 方法进行异步请求，&lt;code&gt;enqueue&lt;/code&gt; 方法进行同步请求，&lt;code&gt;cancle&lt;/code&gt; 方法取消请求和回调。&lt;/li&gt;
&lt;li&gt;OkHttpCall 类：Call 接口的 OKHttp 实现版。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;CallAdapter 接口：提供了 Call 到其他类型数据的转换，可以通过 &lt;code&gt;Retrofit.Builder.addCallAdapterFactory()&lt;/code&gt; 进行配。比如 adapter-rxjava 的实现，就是通过 CallAdapter 接口将 Call 转换为 Observable 的。&lt;/li&gt;
&lt;li&gt;DefaultCallAdapterFactory 类：TODO&lt;/li&gt;
&lt;li&gt;ExecutorCallAdapterFactory 类：如果在 Retrofit 中指定 callbackExecutor 的话，Retrofit 会默认添加添加一个 ExecutorCallAdapterFactory 到 Retrofit 中，将 Call 代理到 ExecutorCallbackCall 中，从而实现 Executor 功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;Converter 接口：实现数据序列化的接口，包含 request 时，model 到 Http 数据的转行和 response 是，Http 数据到 model 的转换。&lt;/li&gt;
&lt;li&gt;BuiltInConverters 类： Retrofit 内部的一个 Converter 实现类，包含一些默认的实现，eg：StringConverter，VoidResponseBodyConverter，StreamingResponseBodyConverter，BufferingResponseBodyConverter。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;ServiceMethod 类：把每次对 Retrofit 传入接口的方法调用定义为 invokeMethod ，ServiceMethod 主要作用就是把 invokeMethod 转换成一次 Http Request，在这里的实现是转成 OKhttp 的 Request，ServiceMethod 包含 invokeMethod 必要信息：比如 bashUrl，请求的 header，请求的参数，注解等等。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;可以说 Retrofit 的主要逻辑都在 ServiceMethod 类中，包含所有注解的解析，参数的获取，Converter 和 CallAdapter 的检索配置等等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;其他的类：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Callback 接口：异步请求时候用的回调接口&lt;/li&gt;
&lt;li&gt;RequestBuilder 类：可以用来创建 OkHttp Request 的 Builder&lt;/li&gt;
&lt;li&gt;Response 类：表示一个 Http response&lt;/li&gt;
&lt;li&gt;ParameterHandler 抽象类：参数添加抽象类，通过对 RequestBuilder 的封装，把 Http 中传输的添加划分得更加详细了。&lt;/li&gt;
&lt;li&gt;Platform 类：针对不同平台进行兼容处理的类。&lt;/li&gt;
&lt;li&gt;packeage Http ：Http 包下是所有 Retrofit 支持的注解&lt;/li&gt;
&lt;li&gt;Utils 类：工具类&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;原理&lt;/h3&gt;
&lt;p&gt;Retrofit 使用的关键技术就是 Java 的动态代理，对接口中每个方法的调用进行代理，从而实现了最终只要写接口和注解就可以进行 Http 请求的效果。这个主要的流程可以直接去看 Retrofit.java 的 crate() 函数，具体如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span class=&quot;function&quot;&gt;T &lt;span class=&quot;title&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Class&amp;lt;T&amp;gt; service)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//检查接口合法性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Utils.validateServiceInterface(service);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (validateEagerly) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        eagerlyValidateMethods(service);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//Java 动态代理 method 的调用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (T) Proxy.newProxyInstance(service.getClassLoader(), &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Class&amp;lt;?&amp;gt;[]&amp;#123;service&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; InvocationHandler() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Platform platform = Platform.get();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Object &lt;span class=&quot;title&quot;&gt;invoke&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object proxy, Method method, Object... args)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Throwable &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;comment&quot;&gt;// If the method is a method from Object then defer to normal invocation.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (method.getDeclaringClass() == Object.class) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; method.invoke(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, args);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (platform.isDefaultMethod(method)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; platform.invokeDefaultMethod(method, service, proxy, args);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;comment&quot;&gt;//将 method 转为 ServiceMethod&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    ServiceMethod serviceMethod = loadServiceMethod(method);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;comment&quot;&gt;//根据 ServiceMethod 生成对应的 OkHttpCall&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    OkHttpCall okHttpCall = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; OkHttpCall&amp;lt;&amp;gt;(serviceMethod, args);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;comment&quot;&gt;//根据 CallAdapter 对 Call 进行转换&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; serviceMethod.callAdapter.adapt(okHttpCall);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;基于 Retrofit 2.0.1 版&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android Framework 层 中的 Binder 机制</title>
    <link href="http://www.baitouwei.com/2016/04/08/Android-Framework-%E5%B1%82-%E4%B8%AD%E7%9A%84-Binder-%E6%9C%BA%E5%88%B6/"/>
    <id>http://www.baitouwei.com/2016/04/08/Android-Framework-层-中的-Binder-机制/</id>
    <published>2016-04-08T00:08:44.000Z</published>
    <updated>2016-04-08T00:27:55.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;基于Android 6.0 源码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Binder 机制：Android 系统提供的 IPC 方式&lt;/h2&gt;
&lt;p&gt;Binder 机制的实现可以分为 3 层：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Android Driver层：Binder还可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder；&lt;/li&gt;
&lt;li&gt;Android Native层：Binder是创建Service Manager以及BpBinder/BBinder模型，搭建与binder驱动的桥梁；&lt;/li&gt;
&lt;li&gt;Android Framework层：Binder是各种Manager（ActivityManager、WindowManager等）和相应xxxManagerService的桥梁；&lt;/li&gt;
&lt;/ol&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4&gt;Binder 架构图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/image/java_binder.jpg&quot; alt=&quot;java_binder.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;Framework 层的 Binder 机制是通过 JNI 层，把请求最终转发到 Native 层，由 Native 层实现实际的通讯过程。而且 Framework 层的 Binder 机制和 Native 层的实现结构差不多，可以理解为是 Native Binder 机制的映射。&lt;/p&gt;
&lt;h4&gt;Framework 层和 Binder 实现相关的类&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/image/binder_classes_of_framework.png&quot; alt=&quot;binder_classes_of_framework.png&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IBinder 接口：远程调用对象的基础接口，核心的方法是&lt;code&gt;transact()&lt;/code&gt;，通过该方法可以与远程调用对象进行通讯。&lt;/li&gt;
&lt;li&gt;Binder 类：远程调用对象的基类，该类一些远程调用对象的标准实现进行了抽象，一般通过继承该类实现 IPC。核心方法是&lt;code&gt;transact()&lt;/code&gt;和&lt;code&gt;onTransact()&lt;/code&gt;，程序可以通过暴露的&lt;code&gt;transact()&lt;/code&gt;进行通讯，&lt;code&gt;transact()&lt;/code&gt;再把数据转发到 protected 的 &lt;code&gt;onTransact()&lt;/code&gt;，实现通讯。&lt;/li&gt;
&lt;li&gt;BinderProxy 类：Binder 的实现类，Framework 层的 Binder 通讯最终都是通过 BinderProxy 代理到 Native 层的。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;BinderProxy 对应的就是 Native 层的 BpBinder，android_util_Binder.cpp 会在 &lt;code&gt;register_android_os_Binder()&lt;/code&gt; 中会对 Binder，BinderInternal，BinderProxy 进行注册，最后使得 BinderInternal.getContextObject() 等于 new BinderProxy()，而在 Framework 层是通过 &lt;code&gt;ServiceManagerNative.asInterface(BinderInternal.getContextObject())&lt;/code&gt; 进行绑定的，其实也就等价于&lt;code&gt;ServiceManagerNative.asInterface(new BinderProxy())&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;IInterface  接口：主要提供一个方法&lt;code&gt;asBinder()&lt;/code&gt;，可以通过这个方法找到对应的 Binder&lt;/li&gt;
&lt;li&gt;IServiceManager 接口：获取和注册系统服务的基础接口&lt;/li&gt;
&lt;li&gt;ServiceManager 类：通过该类可以获取和注册系统服务，实际请求都是由单例的&lt;code&gt;ServiceManagerProxy&lt;/code&gt;进行代理的，ServiceManager 能集中管理系统内的所有服务，它能施加权限控制，并不是任何进程都能注册服务。&lt;/li&gt;
&lt;li&gt;ServiceManagerNative 类：实现获取和注册系统服务抽象类，实际请求都是由&lt;code&gt;ServiceManagerProxy&lt;/code&gt;进行代理的&lt;/li&gt;
&lt;li&gt;ServiceManagerProxy 类：实现获取和注册系统服务的实际类&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;addService():注册服务过程就是通过BpBinder来发送ADD_SERVICE_TRANSACTION命令，与实现与binder驱动进行数据交互。
getService():获取服务过程就是通过BpBinder来发送GET_SERVICE_TRANSACTION命令，与实现与binder驱动进行数据交互。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;Binder进程与线程&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/image/binder_proc_relation.png&quot; alt=&quot;binder_proc_relation.png&quot;&gt;
对于底层Binder驱动，通过binder_procs链表记录所有创建的binder_proc结构体，binder驱动层的每一个binder_proc结构体都与用户空间的一个用于binder通信的进程一一对应，且每个进程有且只有一个ProcessState对象，这是通过单例模式来保证的。在每个进程中可以有很多个线程，每个线程对应一个IPCThreadState对象，IPCThreadState对象也是单例模式，即一个线程对应一个IPCThreadState对象，在Binder驱动层也有与之相对应的结构，那就是Binder_thread结构体。在binder_proc结构体中通过成员变量rb_root threads，来记录当前进程内所有的binder_thread。&lt;/p&gt;
&lt;p&gt;Binder线程池：每个Server进程在启动时会创建一个binder线程池，并向其中注册一个Binder线程；之后Server进程也可以向binder线程池注册新的线程，或者Binder驱动在探测到没有空闲binder线程时会主动向Server进程注册新的的binder线程。对于一个Server进程有一个最大Binder线程数限制，默认为16个binder线程，例如Android的system_server进程就存在16个线程。对于所有Client端进程的binder请求都是交由Server端进程的binder线程来处理的。&lt;/p&gt;
&lt;h4&gt;Binder 传输过程:&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/image/binder_transaction.png&quot; alt=&quot;binder_transaction.png&quot;&gt;
Binder IPC机制，就是指在进程间传输数据（binder_transaction_data），一次数据的传输，称为事务（binder_transaction）。对于多个不同进程向同一个进程发送事务时，这个同一个进程或线程的事务需要串行执行，在Binder驱动中为binder_proc和binder_thread都有todo队列。
也就是说对于进程间的通信，就是发送端把binder_transaction节点，插入到目标进程或其子线程的todo队列中，等目标进程或线程不断循环地从todo队列中取出数据并进行相应的操作。&lt;/p&gt;
&lt;p&gt;binder的路由原理：BpBinder发送端，根据handler，在当前binder_proc中，找到相应的binder_ref，由binder_ref再找到目标binder_node实体，由目标binder_node再找到目标进程binder_proc。简单地方式是直接把binder_transaction节点插入到binder_proc的todo队列中，完成传输过程。
对于binder驱动来说应尽可能地把binder_transaction节点插入到目标进程的某个线程的todo队列，效率更高。当binder驱动可以找到合适的线程，就会把binder_transaction节点插入到相应线程的todo队列中，如果找不到合适的线程，就把节点之间插入binder_proc的todo队列。&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;部分图片引用自&lt;a href=&quot;http://gityuan.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Gityuan 博客&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://gityuan.com/2015/10/31/binder-prepare/#section-1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://gityuan.com/2015/11/28/binder-summary/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;扩展：&lt;/h2&gt;
&lt;p&gt;常见的 IPC 有：&lt;/p&gt;
&lt;h4&gt;IPC(Inter-process communication)进程间通讯方式&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;管道：在创建时分配一个page大小的内存，缓存区大小比较有限；&lt;/li&gt;
&lt;li&gt;消息队列：信息复制两次，额外的CPU消耗；不合适频繁或信息量大的通信；&lt;/li&gt;
&lt;li&gt;共享内存：无须复制，共享缓冲区直接付附加到进程虚拟地址空间，速度快；但进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决；&lt;/li&gt;
&lt;li&gt;套接字：作为更通用的接口，传输效率低，主要用于不通机器或跨网络的通信；&lt;/li&gt;
&lt;li&gt;信号量：常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。&lt;/li&gt;
&lt;li&gt;信号: 不适用于信息交换，更适用于进程中断控制，比如非法内存访问，杀死某个进程等；&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;RPC（Remote Procedure Call Protocol）——远程过程调用协议&lt;/h4&gt;
&lt;p&gt;RPC 是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;基于Android 6.0 源码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Binder 机制：Android 系统提供的 IPC 方式&lt;/h2&gt;
&lt;p&gt;Binder 机制的实现可以分为 3 层：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Android Driver层：Binder还可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder；&lt;/li&gt;
&lt;li&gt;Android Native层：Binder是创建Service Manager以及BpBinder/BBinder模型，搭建与binder驱动的桥梁；&lt;/li&gt;
&lt;li&gt;Android Framework层：Binder是各种Manager（ActivityManager、WindowManager等）和相应xxxManagerService的桥梁；&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android 系统启动流程</title>
    <link href="http://www.baitouwei.com/2016/04/07/Android-%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <id>http://www.baitouwei.com/2016/04/07/Android-系统启动流程/</id>
    <published>2016-04-07T09:34:55.000Z</published>
    <updated>2016-04-07T11:07:00.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;基于Android 6.0 源码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面主要是从 Framework 层开始分析 Android 的启动过程，ZygoteInit.main() 是系统调用的第一个 Java 函数，这里是 c 到 java 的入口，分析从这里开始，整个流程如下：&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;img src=&quot;/image/android_system_start.png&quot; alt=&quot;android_start&quot;&gt;&lt;/p&gt;
&lt;p&gt;Ps:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Zygote 进程是Android系统的首个Java进程，Zygote是所有Java进程的父进程，init 进程 fork 出 Zygote进程（）。&lt;/li&gt;
&lt;li&gt;System Server是Zygote孵化的第一个进程，也是上层framework的运行载体，System Server进程：负责启动和管理整个Java framework，包含ActivityManager，PowerManager等服务。System Server进程由 Zygote进程fork出来。&lt;/li&gt;
&lt;li&gt;Zygote进程接下来会孵化出的第一个App进程是Launcher，这是用户看到的桌面App；Zygote进程还会创建Browser，Phone，Email等App进程，每个App至少运行在一个进程上。
所有的App进程都是由Zygote进程fork生成的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;附录：&lt;/h3&gt;
&lt;h4&gt;服务分类&lt;/h4&gt;
&lt;h4&gt;分类1&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;引导服务：ActivityManagerService、PowerManagerService、LightsService、DisplayManagerService、PackageManagerService、UserManagerService、SensorService共7项服务；&lt;/li&gt;
&lt;li&gt;核心服务：BatteryService、UsageStatsService、WebViewUpdateService共3项服务；&lt;/li&gt;
&lt;li&gt;其他服务：AlarmManagerService、VibratorService等共70多项服务。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;分类2&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;重量级服务：ActivityManagerService、PackageManagerService、WindowManagerService&lt;/li&gt;
&lt;li&gt;功耗相关：PowerManagerService、BatteryService、BatteryStatsService、DreamManagerService&lt;/li&gt;
&lt;li&gt;统计调度相关：DropBoxManagerService、SamplingProfilerService、UsageStatsService、DiskStatsService、SchedulingPolicyService、DeviceStorageMonitorService、AlarmManagerService、DeviceIdleController、DockObserver、ThermalObserver、JobSchedulerService、AccessibilityManagerService&lt;/li&gt;
&lt;li&gt;UI相关：DisplayManagerService、LightsService、GraphicsStatsService、StatusBarManagerService、NotificationManagerService、WallpaperManagerService、UiModeManagerService、AppWidgetService、LauncherAppsService、TextServicesManagerService、ContentService、LockSettingsService、InputManagerService、InputMethodManagerServiceMountService、FingerprintService、TvInputManagerService&lt;/li&gt;
&lt;li&gt;网络相关：NetworkManagementService、NetworkScoreService、NetworkStatsService、NetworkPolicyManagerService、ConnectivityService、BluetoothService、WifiP2pService、WifiService、WifiScanningService、EthernetService、WebViewUpdateService&lt;/li&gt;
&lt;li&gt;Media相关：AudioService、MediaRouterService、VoiceInteractionManagerService、MediaProjectionManagerService、MediaSessionService、&lt;/li&gt;
&lt;li&gt;设备相关：DevicePolicyManagerService、PrintManagerService、BackupManagerService、UserManagerService、AccountManagerService、TrustManagerService、SensorService、LocationManagerService、VibratorService、CountryDetectorService、GestureLauncherService、PersistentDataBlockService、ClipboardService&lt;/li&gt;
&lt;li&gt;其他：TelephonyRegistry、TelecomLoaderService、NsdService、UpdateLockService、SerialService、SearchManagerService、CommonTimeManagementService、AssetAtlasService、ConsumerIrService、MidiServiceCameraService、TwilightService、RestrictionsManagerService、MmsServiceBroker、RttService、UsbService。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;参考 Link：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://gityuan.com/2016/01/30/android-boot/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;1&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;基于Android 6.0 源码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面主要是从 Framework 层开始分析 Android 的启动过程，ZygoteInit.main() 是系统调用的第一个 Java 函数，这里是 c 到 java 的入口，分析从这里开始，整个流程如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.baitouwei.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>ASwipeRefresh</title>
    <link href="http://www.baitouwei.com/2015/11/13/ASwipeRefresh/"/>
    <id>http://www.baitouwei.com/2015/11/13/ASwipeRefresh/</id>
    <published>2015-11-12T16:23:35.000Z</published>
    <updated>2015-11-16T00:45:55.000Z</updated>
    
    <content type="html">&lt;p&gt;之前在做项目的时候，项目里面的下拉刷新控件是一个直接继承 ListView 实现的 PullToRefreshListView。由于是直接集成 ListView 实现的，所以只能在使用 ListView 的场景下才能使用，而且不能很方便的实现多种类型的下拉刷新方式，所以我就写了一个下拉刷新的控件 &lt;a href=&quot;https://github.com/baitouwei/ASwipeRefresh&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ASwipeRefresh&lt;/a&gt;。这个控件主要实现了两件功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;支持自定义下拉刷新的 Header 和 上拉加载更多的 Footer&lt;/li&gt;
&lt;li&gt;支持自定义 Header 和 Footer 的滑出方式&lt;/li&gt;
&lt;/ol&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;这两个功能是我认为比较重要的功能，因为通过组合上面提到的 1 和 2 就可以实现现在的大多数下拉刷新方式。对于现在用的比较多的下拉刷新方式，可以将其分为 4 种类型。一个下拉刷新控件可以分为 Header，Content，和 Footer 三部分，而这四种不同类型的刷新方式之间的主要不同点就是手指拖动的对应的 Header，Content 或 Footer 是否会滑动和这三个 View 在层级（也就是 Z 轴）上的关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/header_content_footer.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;按常见程度排序它们分别是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Normal refresh,普通下拉刷新&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/normal_refresh.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Content（即要滑动的正文视图）滑动的时候，Header 和 Footer 是&lt;strong&gt;同步&lt;/strong&gt;滑动的（即滑动的距离&lt;strong&gt;相等&lt;/strong&gt;）。&lt;/li&gt;
&lt;li&gt;Content 和 Header，Footer 三者在同一层上（即在 Z 轴上是相等的）&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Drawer refresh,抽屉式下拉刷新&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/drawer_refresh.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Content（即要滑动的正文视图）滑动的时候，Header 和 Footer 是&lt;strong&gt;不同步&lt;/strong&gt;滑动的（即滑动的距离&lt;strong&gt;不相等&lt;/strong&gt;），一般常见为 Header 或 Footer 不滑动。&lt;/li&gt;
&lt;li&gt;Content 是在 Header 和 Footer 的上一层视图（即 Content Z 轴上是&lt;strong&gt;最大&lt;/strong&gt;的，Z 轴值大的会覆盖住 Z 轴值小的视图）&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Material refresh&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/material_refresh.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因为这种下拉刷新的方式我最先是在 Google 的 Lollipop 上看到的，所以就命名为Material refresh。这种刷新方式和上面的 Drawer refresh 很类似，区别就是 Header 或 Footer 的 Z 轴值比 Content 的大而且 Content 不会滑动。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Content（即要滑动的正文视图）滑动的时候，Header 和 Footer 是&lt;strong&gt;不同步&lt;/strong&gt;滑动的（即滑动的距离&lt;strong&gt;不相等&lt;/strong&gt;），一般常见为 Content &lt;strong&gt;不滑动&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;Content 是在 Header 和 Footer 的上一层视图（即 Content Z 轴上是&lt;strong&gt;最小&lt;/strong&gt;的，Z 轴值大的会覆盖住 Z 轴值小的视图）&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Side in Refresh&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/side_in_refresh.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这种下拉刷新和 Material refresh 类似，区别就是 Header 或 Footer 改成了由侧面滑入。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Content（即要滑动的正文视图）滑动的时候，Header 和 Footer 是&lt;strong&gt;不同步&lt;/strong&gt;滑动的（即滑动的距离&lt;strong&gt;不相等&lt;/strong&gt;），一般常见为 Content &lt;strong&gt;不滑动&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;Content 是在 Header 和 Footer 的上一层视图（即 Content Z 轴上是&lt;strong&gt;最小&lt;/strong&gt;的，Z 轴值大的会覆盖住 Z 轴值小的视图）&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以这样看来的话，一个可以适应以上所有下拉刷新场景的控件，要满足以下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以自定义 Header，Footer，Content 之间的层级关系（也就是 Z 轴的值）。在　ASwipeRefresh 中对应的是 &lt;code&gt;LayoutLayer&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;可以自定义 Header，Footer 从哪个方向滑动出来，同时还要可以自定义 Header，Footer的初始位置。在　ASwipeRefresh 中对应的分别是&lt;code&gt;LayoutDirection&lt;/code&gt;,&lt;code&gt;OffsetOrientation&lt;/code&gt;，&lt;/li&gt;
&lt;li&gt;可以自定义 Header，Footer，Content 是否可以滑动。在　ASwipeRefresh 中对应的是 &lt;code&gt;parallaxFactor&lt;/code&gt; ，&lt;code&gt;parallaxFactor&lt;/code&gt; 是用来设置滑动时候对应 View 的视差因数的，这里只要设置为 0，对应的 View 也就不会滑动了&lt;/li&gt;
&lt;li&gt;当然还要可以自定义 Header 和 Footer，这里主要是把当前 ASwipeRefresh 滑动的 percent 和 status 传递过去。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除此之外，我还把是否可以进行刷新通过回调 &lt;code&gt;isReadyToRefresh&lt;/code&gt; 和 &lt;code&gt;isReadyToLoadMore&lt;/code&gt; 暴露出来，这样就可以自定义滑动到什么位置才进行刷新。不过现在这个控件还是有缺点的，自动刷新那里处理的不是很好，由于不能缺点一个 View 什么时候已经 ready，所以找不到合适的位置去自动调用下拉刷新，现在的作法通过延时来实现，但其实很不好，无法保证能自动下拉成功，所以要实现自动下拉刷新的话，建议在外部合适的位置手动调用 &lt;code&gt;refreshStart&lt;/code&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;之前在做项目的时候，项目里面的下拉刷新控件是一个直接继承 ListView 实现的 PullToRefreshListView。由于是直接集成 ListView 实现的，所以只能在使用 ListView 的场景下才能使用，而且不能很方便的实现多种类型的下拉刷新方式，所以我就写了一个下拉刷新的控件 &lt;a href=&quot;https://github.com/baitouwei/ASwipeRefresh&quot;&gt;ASwipeRefresh&lt;/a&gt;。这个控件主要实现了两件功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;支持自定义下拉刷新的 Header 和 上拉加载更多的 Footer&lt;/li&gt;
&lt;li&gt;支持自定义 Header 和 Footer 的滑出方式&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="code" scheme="http://www.baitouwei.com/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>okio分析</title>
    <link href="http://www.baitouwei.com/2015/01/08/okio/"/>
    <id>http://www.baitouwei.com/2015/01/08/okio/</id>
    <published>2015-01-08T13:58:58.000Z</published>
    <updated>2015-11-16T00:56:25.000Z</updated>
    
    <content type="html">&lt;p&gt;本篇分析基于&lt;a href=&quot;https://github.com/square/okio&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Okio&lt;/a&gt;1.2.0
Okio是一个对原有的&lt;code&gt;java.io&lt;/code&gt;和&lt;code&gt;java.nio&lt;/code&gt;进行改进的IO库，使IO操作更加高效和方便。Okio的高效主要体现在三个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一它对数据进行了&lt;strong&gt;&lt;em&gt;分块处理&lt;/em&gt;&lt;/strong&gt;，这样在大数据IO的时候可以以块为单位进行IO，这可以提高IO的吞吐率。&lt;/li&gt;
&lt;li&gt;二它对这些数据块使用&lt;strong&gt;&lt;em&gt;链表&lt;/em&gt;&lt;/strong&gt;进行管理，这可以仅通过移动“指针”就进行数据的管理，而不用真正去处理数据，而且对扩容来说也十分方便。&lt;/li&gt;
&lt;li&gt;三对闲置的块进行管理，通过一个块池（SegmentPool）的管理，避免系统GC和申请byte时的zero-fill。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
其他的还有一些小细节上的优化，比如如果你把一个UTF-8的String转为ByteString，ByteString会保留一份对原来String的引用，这样当你下次
需要decode这个String时，程序通过保留的引用直接返回对应的String，从而避免了转码过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Okio的方便主要体现在，它对数据的读取写入进行了封装，调用者可以十分方便的进行各种值(string,short,int,hex,utf-8,base64等等)的转化，还有一点就是它为所有的Source和Sink提供了超时操作，这在Java原生的IO里是没有的。&lt;/p&gt;
&lt;p&gt;###Okio几个基础的类和接口：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;类Segment
一个Segment相当于一个数据块（由一个byte数组构成），一般存在于一个双向循环队列（也就是buffer）或单链表（也就是SegmentPool）中,通过pop()和push(Segment segment)方法可以Segment进行入队和出队操作。Segment部分重要字段如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; SIZE：Segment大小，&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;kb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; pos：指向下一个可读的&lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; limit：指向下一个可写的&lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Segment next：相当于链表的指针，指向下一个Segment&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Segment prev：相当于链表的指针，指向上一个Segment&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类SegmentPool	
一个Segment池，由一个单向链表构成。该池负责Segment的回收和闲置Segment的管理，一般Segment都是从该池获取的。该池是线程安全的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接口Sink，BufferedSink	
Sink和java.io中的OutputStream类似，BufferedSink是一个对Sink进行扩展的接口。使用OutputStream时，在传输不同的数据是需要对OutputStream进行不同的包装，比如用DataOutputStream进行原始数据的IO，用BufferedOutputStream进行带缓存的数据IO，用OutputStreamWriter进行字符编码。对于Sink来说，只需要使用BufferedSink就可以实现以上所有的情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接口Source和BufferedSource
Source和java.io中的InputStream类似，BufferedSource是一个对Source进行扩展的接口。使用InputStream时，在传输不同的数据是需要对InputStream进行不同的包装，比如用DataInputStream进行原始数据的IO，用BufferedInputStream进行带缓存的数据IO，用OutputStreamReader进行字符编码。对于Source来说，只需要使用BufferedSource就可以实现以上所有的情况。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;java.io是由于使用了装饰者模式，才导致了不同的Stream操作需要一层包一层，而Okio没有在这里没有使用装饰者模式，也就不会出现一大堆类的情况。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;类Buffer
Buffer是一个不固定大小的byte序列（由一个节点为Segment的&lt;strong&gt;&lt;em&gt;双向循环队列链表&lt;/em&gt;&lt;/strong&gt;构成），它充当Sink、Source、InputStream和OutputStream间的高效缓存区，由于Buffer实现了BufferedSource和BufferedSink这两个接口，所以可以很方便的对其进行IO操作。Buffer在多线程编程里很有用，比如一个负责网络的线程可以通过这种方式和工作线程进行数据交换，但是又不发生数据的复制。&lt;/li&gt;
&lt;li&gt;类ByteString
ByteString是一个固定大小的byte序列（由一个byte数组构成）。String是Java经常使用到的一个基本类型，ByteString对String进行了封装，为byte和String间的转换和String不同值间的转换（UTF-8编解码，Hex编解码，Base64编解码，ASCIll编解码）提供了十分方便的操作。&lt;/li&gt;
&lt;li&gt;类AsyncTimeout
AsyncTimeout为所有的Source和Sink提供了超时功能，Java原生的IO并没有超时功能，而AsyncTimeout填补了这点。AsyncTimeout的实现原理是：AsyncTimeout相当于一个节点，每个节点都带有tiemout信息，程序维护一条由AsyncTimeout节点组成&lt;strong&gt;&lt;em&gt;优先队列链表&lt;/em&gt;&lt;/strong&gt;（剩余超时时间越小的排越前），然后通过后台的一个守护线程，不断的去轮询这条链表，如果对应节点超时就调用Interrupted进行中断，否则调用wait进行等待。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;###Okio高效在哪里&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;前面说过Okio之所以高效是因为在底层的数据结构上，它维护了一个由Segment构成的链表循环队列，一个Segment相当于一个数据块。这样的好处很明显。因为在一块数据块的进行IO的过程中是没有中断的，相比于每次只读一个byte，单位时间内IO的数据量当然更高。那是不是Segment越大越好？当然不是。因为Segment内数据的IO还是以byte为单位的，如果Segment过大的话，数据就不能很好的进行分块。想象下把数据只分为一个大的Segment，那每次IO不就是以byte为单位了吗？那一个Segment的大小为多少比较合适，在我看来，最好和计算机中的一个页面大小一致。&lt;/li&gt;
&lt;li&gt;另一方面，由于使用了链表，这使得数据的管理十分高效，因为只要移动指针就可以进行数据的移动。SegmentPool是Segment组成的单向链表，负责Segment的回收和闲置Segment的维护。
我们可以看看SegmentPool是如何维护闲置Segment的，SegmentPool提供了两个方法，take()用于获取一个闲置Segment，recycle(Segment segment)用于回收一个Segment。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;Segment &lt;span class=&quot;title&quot;&gt;take&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (next != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	    Segment result = next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	    next = result.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	    result.next = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	    byteCount -= Segment.SIZE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Segment(); &lt;span class=&quot;comment&quot;&gt;// Pool is empty. Don&#39;t zero-fill while holding a lock.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;由于SegmentPool的next指向Pool中闲置的Segment，所以直接返回next指向的Segment就可以了，当没有闲置的Segment是就新建一个返回。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;	void recycle(Segment segment) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	    if (segment.next != null || segment.prev != null) throw new IllegalArgumentException();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	    synchronized (this) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	      if (byteCount + Segment.SIZE &amp;gt; MAX_SIZE) return; // Pool is full.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	      byteCount += Segment.SIZE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	      segment.next = next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	      segment.pos = segment.limit = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	      next = segment;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;```	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在Pool不满的情况下，recycle只要将对应的segment插入到单向链表的头部（也就是next指向segment的前面）就相当于回收了该segment。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;okio的高效主要体现在Buffer中，所以我们可以看看Buffer的实现。由于每个Segment里都有pos和limit两个下标，这和Java NIO里的Buffer有点像，只要通过对pos和limit进行操作，我们就可以判断当前Segment是否写满（limit==SIZE）、是否读完（pos==limit），这就提高了IO的效率了。再看看`readFrom()`和`writeTo()`方法都是尽量以块大小进行IO的。而且为了进行减少调用系统申请内存产生的消耗，Buffer使用了SegmentPool进行Segment的回收和申请。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;###Okio方便在哪里&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1.	Okio之所以方便主要体现在它对许多常用的操作进行了封装，主要体现在BufferedSink和BufferedSource接口为调用者提供了丰富的方法，想基本数据（short，int，long，string）的IO还有Sink和Source之间的转换等，它都提供了相应的方法；另一方面，Okio创建了一个新的数据类型ByteString，ByteString对String进行了封装，为byte和String间的转换和String不同值间的转换（UTF-8编解码，Hex编解码，Base64编解码，ASCIll编解码，大小端转换）提供了十分方便的操作，具体可以查看其相应的方法。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2.	Okio通过AsyncTimeout所有的Source和Sink提供了超时操作。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Timeout是AsyncTimeout的基类，想看看Timeout实现了什么？Timeout对原本的概念进行可扩展，它有两个属性，Timeouts和Deadlines。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	*	Timeouts：代表一个**时间段**，表示等待一个操作执行完毕的最长时间。Timeouts一般用来检测类似网络中断等问题。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	*	Deadlines：代表一个**时间点**，表示一个job（包含多个操作）最长执行到某个时间点。Deadlines可以为一个job设定它的执行时间上限，比如一个对电池电量敏感的APP为了节省电池消耗，也许会在APP content的预加载上设置Deadlines。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	AsyncTimeout的主要字段有：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	```java&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	private static AsyncTimeout head：私有静态变量head，用来当单链表的头&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	private AsyncTimeout next：指向下一个AsyncTiemout的节点&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	private long timeoutAt：根据timeout计算出的timeout时间点&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;要实现对应Source和Sink的Timeout管理只需要管理这条AsyncTimeout优先队列链表就可以了。添加Timeout对应入队（scheduleTimeout方法），取消超时对应出队（cancelScheduledTimeout方法）。守护线程Watchdog，会不断的去轮询这条链表，如果对应节点超时就调用Interrupted进行中断，否则调用wait进行等待。&lt;/p&gt;
&lt;p&gt;###Okio中的其他类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;RealBufferedSink&lt;/code&gt;和&lt;code&gt;RealBufferedSource&lt;/code&gt;，不带缓存的Sink和Source，实现方式是在每次write或read之后都调用emitCompleteSegments()方法（emitCompleteSegments()方法会将Buffer中的数据flush掉）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ForwardingSink&lt;/code&gt;和&lt;code&gt;ForwardingSource&lt;/code&gt;，将调用委托给其他Sink或Source的抽象类，在子类化的时候有用。比如当需要实现一个匿名Sink或Source时，就可以用这个。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GzipSink&lt;/code&gt;和&lt;code&gt;GzipSource&lt;/code&gt;，实现了Gzip的Sink和Source。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DeflaterSink&lt;/code&gt;和&lt;code&gt;InflaterSource&lt;/code&gt;，实现了ZLIB压缩和解压的Sink和Source，在DeflaterSink这个类中，由于每次调用flush()程序都会对整个Buffer进行同步压缩，所以官方建议只在程序有必要时才主动去调用flush(),否则频繁的调用flush()会引起性能上的问题。
从上面这些类看出，我们完全可以对Sink和Source进行扩展，以实现一些针对不同compression或encryption的Sink和Source，比如可以编写针对H264的H264EnCodeSink和H264DeCodeSource。&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本篇分析基于&lt;a href=&quot;https://github.com/square/okio&quot;&gt;Okio&lt;/a&gt;1.2.0
Okio是一个对原有的&lt;code&gt;java.io&lt;/code&gt;和&lt;code&gt;java.nio&lt;/code&gt;进行改进的IO库，使IO操作更加高效和方便。Okio的高效主要体现在三个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一它对数据进行了&lt;strong&gt;&lt;em&gt;分块处理&lt;/em&gt;&lt;/strong&gt;，这样在大数据IO的时候可以以块为单位进行IO，这可以提高IO的吞吐率。&lt;/li&gt;
&lt;li&gt;二它对这些数据块使用&lt;strong&gt;&lt;em&gt;链表&lt;/em&gt;&lt;/strong&gt;进行管理，这可以仅通过移动“指针”就进行数据的管理，而不用真正去处理数据，而且对扩容来说也十分方便。&lt;/li&gt;
&lt;li&gt;三对闲置的块进行管理，通过一个块池（SegmentPool）的管理，避免系统GC和申请byte时的zero-fill。
    
    </summary>
    
    
      <category term="code" scheme="http://www.baitouwei.com/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>2014阅读书单</title>
    <link href="http://www.baitouwei.com/2014/12/28/2014%E9%98%85%E8%AF%BB%E4%B9%A6%E5%8D%95/"/>
    <id>http://www.baitouwei.com/2014/12/28/2014阅读书单/</id>
    <published>2014-12-28T09:06:05.000Z</published>
    <updated>2016-04-08T00:41:22.000Z</updated>
    
    <content type="html">&lt;h4&gt;非技术类&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;《解忧杂货铺》
&lt;img src=&quot;/image/%E8%A7%A3%E5%BF%A7%E6%9D%82%E8%B4%A7%E9%93%BA.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2014看过的最好看的小说，故事情节一环扣一环，故事仅在一个晚上的时间就把几十年的事情都串起来，这种设定让我读完后有一种好像在一瞬间经历了几十年了错觉。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;《三体》
&lt;img src=&quot;/image/%E4%B8%89%E4%BD%93.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;大名鼎鼎的三体，8月份左右读的，三部连着看，也是十分精彩，力荐。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;《白夜行》
&lt;img src=&quot;/image/%E7%99%BD%E5%A4%9C%E8%A1%8C.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;《一个人的朝圣》
&lt;img src=&quot;/image/%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%9C%9D%E5%9C%A3.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个朝圣路就是主人公在晚年的时候回顾自己的一生的过程，主人公通过徒步的方式，物理刺激肉体，从而引导其心理上的自我反省和救赎。是一本内心独白的小说。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;《职场动物进化手册》
&lt;img src=&quot;/image/%E8%81%8C%E5%9C%BA%E5%8A%A8%E7%89%A9%E8%BF%9B%E5%8C%96%E6%89%8B%E5%86%8C.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这本书看看就好，现实生活要现实分析。不过作者的这种用动物来比喻人的写法，我当时读的时候感觉很新鲜，这种叙事方式相当的幽默婉转。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;《如何阅读一本书》
&lt;img src=&quot;/image/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这本是我2014年读的最好的书，没有之一，虽然以前读过，不过这次才算真正读了这本书。总结下来重点就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;弄明白你读一本书的意义，也就是你为什么要读某一本书？读了它可以给你带来什么？&lt;/li&gt;
&lt;li&gt;给你读的书分类。目前来说，我就简单分为实用类和非实用类，实用类就是教你怎么做某件事的书，反之就是非实用类，像《如何阅读一本书》显然就是实用类的书，而大多数哲学类的书就是非使用类的书，前面提到的《一个人的朝圣路》就是非实用类书。&lt;/li&gt;
&lt;li&gt;先略读，通过封面，目录，前言或者翻阅前几章和最后一章等方式，大致了解一本书后再去决定要不要细读。这样可以节省很多时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是一本非常不错的书，推荐每个读书的人都应该认真的去读下。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;《把时间当朋友》
&lt;img src=&quot;/image/%E6%8A%8A%E6%97%B6%E9%97%B4%E5%BD%93%E6%9C%8B%E5%8F%8B.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;《暗时间》
&lt;img src=&quot;/image/%E6%9A%97%E6%97%B6%E9%97%B4.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;暗时间在我理解来就是潜意识，不过书中的元知识的观点很受用啊，其实也就是我们常说的基础，基础打的好，才能爬得高。我看完后就决定去好好看看《深入理解计算机系统》这本书。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;《影响力》
&lt;img src=&quot;/image/%E5%BD%B1%E5%93%8D%E5%8A%9B.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;《中国人的焦虑从哪里来》
&lt;img src=&quot;/image/%E4%B8%AD%E5%9B%BD%E4%BA%BA%E7%9A%84%E7%84%A6%E8%99%91%E4%BB%8E%E5%93%AA%E9%87%8C%E6%9D%A5.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;书里有一个观点，就是劳动不能创造财富，财富是通过交换来创造的。也就是说，把一样物品放到合适的地方，它就可以产生财富，这也就是商人干的事情，古代的物物交换就是这样的。还有一点就是平等分析的最后其实就是尊重人权。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;《学习之道》
&lt;img src=&quot;/image/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%81%93.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;第一个看这本书的名字还以为是一本教你如何快速记忆子类的书籍，感觉名字起的不好，读完之后才发觉其实名字起的挺好的。道，其实就是道可道，非常道。这本书讲的更多的是学习过程中心理上的调整，教你如何通过心理调整更好的学习，更好的体会学习。这本书，属于那种适合重读多遍的书。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;《程序员的思维修炼》
&lt;img src=&quot;/image/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%80%9D%E7%BB%B4%E4%BF%AE%E7%82%BC.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;讲的是右脑的开发，和《暗时间》那本书有相似之处，都是讲潜意识的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;《活法》
&lt;img src=&quot;/image/%E6%B4%BB%E6%B3%95.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;原本以为是一本人生指导手册子类的书，读完才发现其实就是稻盛和夫讲述他的经营之道。其实这也是相通 的，一个企业的经营之道和它创始人的做人之道是息息相关的，可以这么说，企业就是其创始人的延伸，企业的经营之道就是其创始人的做人之道的延伸，这么来说的话，这本书讲的也就是稻盛和夫的做人之道，也就是他的活法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;技术类&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;《深入理解计算机系统》
&lt;img src=&quot;/image/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;关于计算机机存储这块的内容讲的十分好，前面的知识都是后面讲述内容的基础，推荐按照章节顺序阅读。我阅读的时候是按照章节，调整把存储相关的内容读完的，这样读每次只针对一个知识点来，对我来说效率更好。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;《Head First设计模式》
&lt;img src=&quot;/image/Head_First%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;设计模式入门好书，简单易懂。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;《Java网络编程》
&lt;img src=&quot;/image/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;读到Java IO那里，最好先去看看装饰者模式，这样可以更好的理解Java IO，为什么Java IO有那么多个类？推荐《Head_First设计模式》&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;《Java NIO》
&lt;img src=&quot;/image/Java_NIO.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Java NIO的入门好书，关于NIO的讲的很详细。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h4&gt;非技术类&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;《解忧杂货铺》
&lt;img src=&quot;/image/%E8%A7%A3%E5%BF%A7%E6%9D%82%E8%B4%A7%E9%93%BA.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2014看过的最好看的小说，故事情节一环扣一环，故事仅在一个晚上的时间就把几十年的事情都串起来，这种设定让我读完后有一种好像在一瞬间经历了几十年了错觉。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="read" scheme="http://www.baitouwei.com/tags/read/"/>
    
  </entry>
  
</feed>
